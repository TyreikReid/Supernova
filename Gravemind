<#
.SYNOPSIS
   Tools to better assist w/ job functions.

.DESCRIPTION
    Call function manually to better assist w/ work itself.
#>

Function UpdateWindows {
        # Part 1: Show last 5 installed updates
    Write-Host "Retrieving the last 5 Windows Update events..." -ForegroundColor Green
    try {
        $lastUpdates = Get-WinEvent -LogName System -FilterXPath '
            *[System[Provider[@Name="Microsoft-Windows-WindowsUpdateClient"] and
            (EventID=19 or EventID=20)]]' | 
            Select-Object -First 5 -Property TimeCreated, Message

        if ($lastUpdates) {
            Write-Host "`nLast 5 Installed Updates:" -ForegroundColor Green
            $lastUpdates | Format-Table TimeCreated, Message -AutoSize
        } else {
            Write-Host "No previous updates found in the system logs." -ForegroundColor Red
        }
    } catch {
        Write-Host "Error: Failed to retrieve update history." -ForegroundColor Red
        exit
    }

    # Wait for user input before proceeding
    Write-Host "`nPress Enter to search for pending updates..." -ForegroundColor Green
    Read-Host

    # Part 2: Search for and handle pending updates
    Write-Host "Checking for pending updates..." -ForegroundColor Green

    # Ensure PSWindowsUpdate is installed
    try {
        if (!(Get-Module -ListAvailable PSWindowsUpdate)) {
            Install-Module PSWindowsUpdate -Force -Scope CurrentUser -ErrorAction Stop
            Write-Host "PSWindowsUpdate module installed successfully." -ForegroundColor Green
        }
        Import-Module PSWindowsUpdate -ErrorAction Stop
        Write-Host "PSWindowsUpdate module imported successfully." -ForegroundColor Green
    } catch {
        Write-Host "Error: Failed to install or import PSWindowsUpdate module." -ForegroundColor Red
        exit
    }

    # Temporarily set execution policy to Bypass for this session
    $originalPolicy = Get-ExecutionPolicy
    Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass -Force

    # Get outstanding updates
    try {
        $outstanding = Get-WindowsUpdate -ErrorAction Stop

        if ($outstanding.Count -eq 0) {
            Write-Host "No outstanding updates found." -ForegroundColor Green
        } else {
            Write-Host "`nThere are $($outstanding.Count) outstanding updates available." -ForegroundColor Green

            # Display numbered list
            Write-Host "`nAvailable Updates:" -ForegroundColor Yellow
            for ($i = 0; $i -lt $outstanding.Count; $i++) {
                $u = $outstanding[$i]
                $num = $i + 1
                Write-Host "[$num] $($u.KB) - $($u.Title) ($([math]::Round($u.Size/1MB,2)) MB)"
            }

            # Ask which to skip
            Write-Host "`nEnter update numbers to SKIP (comma-separated), or press Enter to install all:" -ForegroundColor Cyan
            $skipInput = Read-Host
            $toInstall = if ([string]::IsNullOrWhiteSpace($skipInput)) {
                $outstanding
            } else {
                # parse skip list
                $skipNums = $skipInput -split '\s*,\s*' |
                            Where-Object { $_ -match '^[0-9]+$' } |
                            ForEach-Object { [int]$_ }
                # filter
                $outstanding | Where-Object { ($outstanding.IndexOf($_) + 1) -notin $skipNums }
            }

            if ($toInstall.Count -eq 0) {
                Write-Host "No updates selected for installation." -ForegroundColor Yellow
            } else {
                Write-Host "`nInstalling $($toInstall.Count) updates..." -ForegroundColor Green
                try {
                    # install only selected updates
                    foreach ($update in $toInstall) {
        try {
            Write-Host "Installing: $($update.Title)" -ForegroundColor Cyan
            Install-WindowsUpdate -Title $update.Title -AcceptAll -IgnoreReboot -ErrorAction Stop
        } catch {
            Write-Host "Error installing $($update.Title): $_" -ForegroundColor Red
        }
    }

                    Write-Host "Updates installed successfully." -ForegroundColor Green
                } catch {
                    Write-Host "Error: Failed to install updates. $_" -ForegroundColor Red
                }
            }
        }
    } catch {
        Write-Host "Error: Failed to retrieve updates. $_" -ForegroundColor Red
    }

    # Reset execution policy to the original setting
    Set-ExecutionPolicy -Scope Process -ExecutionPolicy $originalPolicy -Force
    Write-Host "Execution policy reset to original settings." -ForegroundColor Green
    Read-Host "Press enter to continue."


}
Function NetAdapt {
        function Show-Adapters {
        do {
            Clear-Host
            $adapters = Get-NetAdapter | Where-Object { $_.Status -eq 'Up' }
            if (-not $adapters) {
                Write-Error "No active network adapters found."
                return
            }

            Write-Host "`nAvailable Network Adapters:" -ForegroundColor Cyan
            Write-Host "0. Exit"
            $adapters | ForEach-Object -Begin { $i = 1 } -Process {
                Write-Host "$i. $($_.Name)"
                $i++
            }

            $adapterChoice = Read-Host "`nSelect adapter number"
            if ($adapterChoice -eq '0') { return }

            $selectedAdapter = $adapters[$adapterChoice - 1]
            if ($selectedAdapter) {
                Show-Properties -AdapterName $selectedAdapter.Name
            } else {
                Write-Host "❌ Invalid selection. Press Enter to try again." -ForegroundColor Red
                Read-Host
            }

        } while ($true)
    }

    function Show-Properties {
        param ([string]$AdapterName)

        do {
            Clear-Host
            $props = Get-NetAdapterAdvancedProperty -Name $AdapterName
            if (-not $props) {
                Write-Error "No advanced properties found for $AdapterName"
                return
            }

            Write-Host "`nAdvanced Properties for adapter: $AdapterName" -ForegroundColor Cyan
            Write-Host "0. Back"
            $props | ForEach-Object -Begin { $j = 1 } -Process {
                Write-Host "$j. $($_.DisplayName): $($_.DisplayValue)"
                $j++
            }

            $propChoice = Read-Host "`nSelect property number to modify"
            if ($propChoice -eq '0') { return }

            $selectedProp = $props[$propChoice - 1]
            if ($selectedProp) {
                Show-PropertyEditor -AdapterName $AdapterName -Prop $selectedProp
            } else {
                Write-Host "❌ Invalid selection. Press Enter to try again." -ForegroundColor Red
                Read-Host
            }

        } while ($true)
    }

    function Show-PropertyEditor {
        param (
            [string]$AdapterName,
            $Prop
        )

        do {
            Clear-Host
            Write-Host "`nModify Property: $($Prop.DisplayName)" -ForegroundColor Yellow
            Write-Host "Current Value: $($Prop.DisplayValue)"
            Write-Host ""

            # Try both singular and plural variants
            $validValues = @()
            if ($Prop.PSObject.Properties.Name -contains 'ValidDisplayValue') {
                $validValues = $Prop.ValidDisplayValue
            }
            elseif ($Prop.PSObject.Properties.Name -contains 'ValidDisplayValues') {
                $validValues = $Prop.ValidDisplayValues
            }

            if ($validValues.Count -gt 0) {
                Write-Host "0. Back"
                $validValues | ForEach-Object -Begin { $k = 1 } -Process {
                    Write-Host "$k. $_"
                    $k++
                }

                $valChoice = Read-Host "`nSelect new value number"
                if ($valChoice -eq '0') { return }

                $newValue = $validValues[$valChoice - 1]
            } else {
                $newValue = Read-Host "`nNo predefined values found. Enter new value manually (or 0 to cancel)"
                if ($newValue -eq '0') { return }
            }

            try {
                Set-NetAdapterAdvancedProperty -Name $AdapterName `
                    -DisplayName $Prop.DisplayName `
                    -DisplayValue $newValue -NoRestart
                Write-Host "`n✅ Property updated successfully!" -ForegroundColor Green
            } catch {
                Write-Error "❌ Failed to update property: $_"
            }

            Read-Host "`nPress Enter to return"
            return

        } while ($true)
    }


    # Launch the interactive tool
    Show-Adapters

}
Function SpeedTest {
# Define package name
$PackageName = "speedtest"

# Check if installed
$PackageCheck = choco list --local-only | Select-String "^$PackageName\s"

if ($PackageCheck) {
    Write-Host "✔ $PackageName is already installed. Reinstalling..."
    choco install $PackageName --force -y > $null 2>&1
} else {
    Write-Host "ℹ $PackageName not found. Installing..."
    choco install $PackageName -y > $null 2>&1
}

# Run it from Chocolatey's bin folder
$ExePath = "$env:ChocolateyInstall\bin\speedtest.exe"

if (Test-Path $ExePath) {
    Write-Host "`n=== 25 down, 3 up ==="
    & $ExePath
    Write-Host "`nPress Enter to continue..."
    Read-Host
} else {
    Write-Host "ERROR: speedtest.exe not found at $ExePath"
}


}
Function ClearSpace {
   # Set Execution Policy to bypass for the current session
Set-ExecutionPolicy Bypass -Scope Process -Force

# Function to get the available free space on the drive
function Get-FreeSpace {
    $drive = Get-PSDrive -Name C
    return $drive.Used, $drive.Free
}

# Record initial free space
$initialUsedSpace, $initialFreeSpace = Get-FreeSpace

# Start Component Cleanup using DISM
Write-Host "Starting DISM component cleanup..."

try {
    $process = Start-Process -FilePath "Dism.exe" `
        -ArgumentList "/Online", "/Cleanup-Image", "/StartComponentCleanup", "/ResetBase" `
        -WindowStyle Hidden -Wait -PassThru

    if ($process.ExitCode -eq 0) {
        Write-Host "DISM cleanup complete."
    }
    else {
        Write-Host "DISM exited with code $($process.ExitCode)." -ForegroundColor Yellow
    }
}
catch {
    Write-Host "An error occurred while running DISM: $_" -ForegroundColor Red
}


# Stop Windows Update services to clean SoftwareDistribution folder contents
Write-Host "Stopping Windows Update and Background Intelligent Transfer services... "
Stop-Service -Name wuauserv -ErrorAction SilentlyContinue
Stop-Service -Name bits -ErrorAction SilentlyContinue
Write-Host "Services stopped."

# Clean up the SoftwareDistribution folder contents using robocopy
$SoftwareDistributionPath = "C:\Windows\SoftwareDistribution"
if (Test-Path $SoftwareDistributionPath -ErrorAction SilentlyContinue) {
    Write-Host "Cleaning up SoftwareDistribution folder contents..."
    # Use robocopy to effectively delete the contents
    $TempPath = Join-Path $SoftwareDistributionPath "empty"
    New-Item -ItemType Directory -Path $TempPath -Force | Out-Null
    robocopy $TempPath $SoftwareDistributionPath /MIR /XD $TempPath
    Remove-Item -Recurse -Force -Path $TempPath
    Write-Host "SoftwareDistribution folder contents deleted."
} else {
    Write-Host "SoftwareDistribution folder not found."
}

# Restart the stopped services (Windows Update and BITS)
Write-Host "Restarting Windows Update and Background Intelligent Transfer services... "
Start-Service -Name wuauserv -ErrorAction SilentlyContinue
Start-Service -Name bits -ErrorAction SilentlyContinue
Write-Host "Services restarted."

# Cleanup temp files for all user profiles except "Public" and "Default"
Write-Host "Cleaning temp files for all users except 'Public' and 'Default'..."

# Get all user profile directories except "Public" and "Default"
$UserProfiles = Get-ChildItem "C:\Users" | Where-Object { 
    $_.Name -notin @('Public', 'Default') -and $_.PSIsContainer 
}

# Initialize a list to store the names of users whose temp files were deleted
$deletedUsers = @()

# Loop through each user profile and delete temp files
foreach ($UserProfile in $UserProfiles) {
    $TempFolder = Join-Path $UserProfile.FullName "AppData\Local\Temp"

    if (Test-Path $TempFolder -ErrorAction SilentlyContinue) {
        try {
            # Delete all contents in the Temp folder
            Get-ChildItem $TempFolder -Recurse | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
            $deletedUsers += $UserProfile.Name
        } catch {
            Write-Host "Failed to delete temp files for user: $($UserProfile.Name) - $_"
        }
    }
}

# Output the names of all users whose temp files were deleted, grouped together
if ($deletedUsers.Count -gt 0) {
    Write-Host "Temp files deleted for users: $($deletedUsers -join ', ')"
} else {
    Write-Host "No temp files were deleted."
}

Write-Host "Temp folder cleanup complete."

# Calculate and output total space cleared
$finalUsedSpace, $finalFreeSpace = Get-FreeSpace
$spaceFreed = $finalFreeSpace - $initialFreeSpace

Write-Host "Initial free space: $([math]::Round($initialFreeSpace / 1GB, 2)) GB"
Write-Host "Final free space: $([math]::Round($finalFreeSpace / 1GB, 2)) GB"
Write-Host "Total space freed: $([math]::Round($spaceFreed / 1GB, 2)) GB"

Write-Host "Disk space cleanup complete."
 
}
Function Bookmark {
    # Menu-driven browser bookmark exporter
# Combines the simple HTML layout of the first script with the menu/UX of the second.
# Outputs UTF-8 bookmark HTML files compatible with Chrome/Edge import.

# --------------------
# Browser paths to locate bookmark sources
$BrowserPaths = @{
    "Google Chrome"     = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks"
    "Microsoft Edge"    = "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks"
    "Mozilla Firefox"   = "$env:APPDATA\Mozilla\Firefox\Profiles"
    "Internet Explorer" = "$env:USERPROFILE\Favorites"
    "Brave"             = "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data\Default\Bookmarks"
    "Opera"             = "$env:APPDATA\Opera Software\Opera Stable\Bookmarks"
}

# Output setup
$OutputFolder = Join-Path $env:TEMP "Browser_Bookmarks"
if (-not (Test-Path $OutputFolder)) { New-Item -ItemType Directory -Path $OutputFolder | Out-Null }
$LogFile = Join-Path $OutputFolder "Bookmark_Copy_Log.txt"
"===== Bookmark Backup Run: $(Get-Date -Format u) =====" | Out-File -FilePath $LogFile -Append

# --------------------
# HTML header (Netscape/Chrome import friendly)
function Start-BookmarkHtml { param($title = "Bookmarks")
    return @"
<!DOCTYPE NETSCAPE-Bookmark-file-1>
<!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>$title</TITLE>
<H1>$title</H1>
<DL><p>
"@
}

# Timestamp conversion: Chrome stores microseconds since 1601; convert to UNIX seconds
function Convert-ChromeTimestampToUnix {
    param([string]$chromeTs)
    if (-not $chromeTs) { return "" }
    try {
        $n = [int64]$chromeTs
        if ($n -le 0) { return "" }
        $unixSeconds = [math]::Floor(($n / 1000000) - 11644473600)
        return [string]$unixSeconds
    } catch { return "" }
}

# HTML encode helper
function HtmlEncode([string]$s) { if ($null -eq $s) { return "" } ; return [System.Net.WebUtility]::HtmlEncode($s) }

# Safe filename helper
function Make-SafeFileName([string]$s) {
    if ($null -eq $s) { return "bookmarks" }
    $invalid = [System.IO.Path]::GetInvalidFileNameChars() + [System.IO.Path]::GetInvalidPathChars()
    $out = $s
    foreach ($c in $invalid) { $out = $out -replace [regex]::Escape($c), "_" }
    $out = $out -replace "_+", "_"
    return $out.Trim("_")
}

# --------------------
# Chromium JSON -> Netscape Bookmark HTML (robust)
function Convert-ChromiumBookmarksToHtml {
    param(
        [Parameter(Mandatory=$true)][string]$jsonPath,
        [Parameter(Mandatory=$true)][string]$outputFile
    )

    if (-not (Test-Path $jsonPath)) { throw "Bookmarks JSON not found: $jsonPath" }

    # Copy to temp to avoid lock issues
    try {
        $tmp = Join-Path $env:TEMP ("Bookmarks_copy_" + ([System.Guid]::NewGuid().ToString()) + ".json")
        Copy-Item -Path $jsonPath -Destination $tmp -Force -ErrorAction Stop
    } catch {
        Add-Content -Path $LogFile -Value "Warning: could not copy Bookmarks file. Reading in place. $($_.Exception.Message)"
        $tmp = $jsonPath
    }

    $json = Get-Content $tmp -Raw | ConvertFrom-Json -ErrorAction Stop
    $html = Start-BookmarkHtml "Bookmarks"

    # recursive builder returns string (safe closure)
    function Build-BookmarksHtml {
        param($nodes, $level)
        $out = ""
        if (-not $nodes) { return $out }

        foreach ($n in $nodes) {
            # folder (be tolerant to 'folder' case)
            if ($n.type -and ($n.type.ToString().ToLower() -eq "folder")) {
                $name = if ($n.name) { $n.name } else { "Folder" }
                $add = Convert-ChromeTimestampToUnix $n.date_added
                $mod = Convert-ChromeTimestampToUnix $n.date_modified
                $attrs = @()
                if ($add) { $attrs += "ADD_DATE=`"$add`"" }
                if ($mod) { $attrs += "LAST_MODIFIED=`"$mod`"" }
                $attrString = if ($attrs.Count -gt 0) { " " + ($attrs -join " ") } else { "" }

                $out += ("`t" * $level) + "<DT><H3$attrString>$([System.Net.WebUtility]::HtmlEncode($name))</H3>`n"
                $out += ("`t" * $level) + "<DL><p>`n"

                if ($n.children) { $out += Build-BookmarksHtml $n.children ($level + 1) }

                $out += ("`t" * $level) + "</DL><p>`n"
            }
            # link (tolerant)
            elseif ($n.url -or ($n.type -and ($n.type.ToString().ToLower() -eq "url"))) {
                $title = if ($n.name) { $n.name } else { $n.url }
                $url = $n.url
                $add = Convert-ChromeTimestampToUnix $n.date_added
                $itemAttrs = @()
                if ($add) { $itemAttrs += "ADD_DATE=`"$add`"" }
                if ($n.icon) { $itemAttrs += "ICON=`"$([System.Net.WebUtility]::HtmlEncode($n.icon))`"" }
                $itemAttrString = if ($itemAttrs.Count -gt 0) { " " + ($itemAttrs -join " ") } else { "" }

                $out += ("`t" * $level) + "<DT><A HREF=`"" + [System.Net.WebUtility]::HtmlEncode($url) + "`"$itemAttrString>$([System.Net.WebUtility]::HtmlEncode($title))</A>`n"
            }
            # unknown but has children
            elseif ($n.children) {
                $out += Build-BookmarksHtml $n.children $level
            }
        }
        return $out
    }

    # iterate all roots
    foreach ($rootProp in $json.roots.PSObject.Properties) {
        $rootName = $rootProp.Name
        $root = $json.roots.$rootName
        if (-not $root) { continue }

        $isToolbar = ($rootName -eq "bookmark_bar")
        $rootTitle = if ($root.name) { $root.name } else { $rootName }
        $rootAdd = Convert-ChromeTimestampToUnix $root.date_added
        $rootMod = Convert-ChromeTimestampToUnix $root.date_modified

        $attrs = @()
        if ($rootAdd) { $attrs += "ADD_DATE=`"$rootAdd`"" }
        if ($rootMod) { $attrs += "LAST_MODIFIED=`"$rootMod`"" }
        if ($isToolbar) { $attrs += "PERSONAL_TOOLBAR_FOLDER=`"true`"" }
        $attrString = if ($attrs.Count -gt 0) { " " + ($attrs -join " ") } else { "" }

        $html += "    <DT><H3$attrString>$([System.Net.WebUtility]::HtmlEncode($rootTitle))</H3>`n"
        $html += "    <DL><p>`n"
        $html += Build-BookmarksHtml $root.children 2
        $html += "    </DL><p>`n"
    }

    $html += "</DL><p>`n"

    # write file (UTF8, no BOM)
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($html)
    [System.IO.File]::WriteAllBytes($outputFile, $bytes)

    if ($tmp -ne $jsonPath -and (Test-Path $tmp)) { Remove-Item $tmp -Force -ErrorAction SilentlyContinue }
}

# --------------------
# Firefox (places.sqlite) -> netscape HTML (simple)
function Convert-FirefoxToHtml {
    param([Parameter(Mandatory=$true)][string]$sqlitePath, [Parameter(Mandatory=$true)][string]$outputFile)
    if (-not (Test-Path $sqlitePath)) { throw "Firefox places.sqlite not found: $sqlitePath" }
    $tmpDb = Join-Path $env:TEMP ("places_copy_" + ([System.Guid]::NewGuid().ToString()) + ".sqlite")
    Copy-Item -Path $sqlitePath -Destination $tmpDb -Force
    $html = Start-BookmarkHtml "Firefox Bookmarks"
    try {
        if (-not ([type]::GetType("System.Data.SQLite.SQLiteConnection", $false))) {
            try { [Reflection.Assembly]::LoadWithPartialName("System.Data.SQLite") | Out-Null } catch {}
        }
        if (-not ([type]::GetType("System.Data.SQLite.SQLiteConnection", $false))) {
            Add-Content -Path $LogFile -Value "System.Data.SQLite not available. Firefox export may fail. ($sqlitePath)"
            throw "System.Data.SQLite not available"
        }
        $cn = "Data Source=$tmpDb;Version=3;"
        $conn = New-Object System.Data.SQLite.SQLiteConnection($cn); $conn.Open()
        $cmd = $conn.CreateCommand()
        $cmd.CommandText = @"
SELECT p.url AS url, b.title AS title, b.dateAdded
FROM moz_bookmarks b
JOIN moz_places p ON b.fk = p.id
WHERE p.url IS NOT NULL
ORDER BY b.dateAdded DESC
LIMIT 2000
"@
        $reader = $cmd.ExecuteReader()
        while ($reader.Read()) {
            $url = $reader["url"]
            $title = if ($reader["title"]) { $reader["title"] } else { $url }
            $addDate = $reader["dateAdded"]
            $addAttr = ""
            if ($addDate -and ($addDate -as [int64])) {
                try { $addSec = [math]::Floor(($addDate / 1000000)); $addAttr = " ADD_DATE=`"$addSec`"" } catch {}
            }
            $html += "<DT><A HREF=`"" + [System.Net.WebUtility]::HtmlEncode($url) + "`"$addAttr>$([System.Net.WebUtility]::HtmlEncode($title))</A>`n"
        }
        $reader.Close(); $conn.Close()
    } catch {
        Add-Content -Path $LogFile -Value "Firefox export failed for $sqlitePath : $($_.Exception.Message)"
        $html += "<!-- Firefox export failed: $($_.Exception.Message) -->`n"
    } finally {
        if (Test-Path $tmpDb) { Remove-Item $tmpDb -Force -ErrorAction SilentlyContinue }
    }
    $html += "</DL><p>"
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($html); [System.IO.File]::WriteAllBytes($outputFile, $bytes)
}

# --------------------
# Internet Explorer Favorites -> HTML
function Convert-IEFavoritesToHtml {
    param([Parameter(Mandatory=$true)][string]$favPath, [Parameter(Mandatory=$true)][string]$outputFile)
    $html = Start-BookmarkHtml "Internet Explorer Favorites"
    if (-not (Test-Path $favPath)) { Add-Content -Path $LogFile -Value "IE Favorites path not found: $favPath" }
    else {
        $urls = Get-ChildItem $favPath -Recurse -Include *.url -ErrorAction SilentlyContinue
        foreach ($u in $urls) {
            $content = Get-Content $u.FullName -ErrorAction SilentlyContinue
            $url = ($content | Where-Object { $_ -like "URL=*" }) -replace "URL=", ""
            $html += "<DT><A HREF=`"" + [System.Net.WebUtility]::HtmlEncode($url) + "`">$([System.Net.WebUtility]::HtmlEncode($u.BaseName))</A>`n"
        }
    }
    $html += "</DL><p>"
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($html); [System.IO.File]::WriteAllBytes($outputFile, $bytes)
}

# --------------------
# Detect installed browsers and populate menu
$AvailableBrowsers = @{}
foreach ($browser in $BrowserPaths.Keys) {
    $path = $BrowserPaths[$browser]
    if ($browser -eq "Mozilla Firefox") {
        if (Test-Path $path) {
            $profiles = Get-ChildItem $path -Directory -ErrorAction SilentlyContinue
            foreach ($profile in $profiles) {
                $places = Join-Path $profile.FullName "places.sqlite"
                if (Test-Path $places) { $AvailableBrowsers["$browser ($($profile.Name))"] = $places }
            }
        }
    } else {
        if (Test-Path $path) { $AvailableBrowsers[$browser] = $path }
    }
}

if ($AvailableBrowsers.Count -eq 0) { Write-Host "No supported browsers found."; exit }

# Menu display
Write-Host "`nDetected browsers with bookmark/favorite files:`n"
$i = 1; $BrowserIndex = @{}
foreach ($browser in $AvailableBrowsers.Keys) {
    Write-Host "[$i] $browser"
    $BrowserIndex[$i] = $browser
    $i++
}

$selection = Read-Host "`nEnter number(s) of browser(s) to export (comma separated)"
$selectedIndexes = $selection -split "," | ForEach-Object { $_.Trim() } | Where-Object { $_ -match '^\d+$' }

# Export selected entries
foreach ($index in $selectedIndexes) {
    if ($BrowserIndex.ContainsKey([int]$index)) {
        $browserName = $BrowserIndex[[int]$index]
        $sourcePath = $AvailableBrowsers[$browserName]
        $safeName = Make-SafeFileName($browserName.Replace(" ", "_"))
        $destFile = Join-Path $OutputFolder ($safeName + "_Bookmarks.html")

        try {
            if ($browserName -like "Google Chrome*") { Convert-ChromiumBookmarksToHtml -jsonPath $sourcePath -outputFile $destFile }
            elseif ($browserName -like "Microsoft Edge*") { Convert-ChromiumBookmarksToHtml -jsonPath $sourcePath -outputFile $destFile }
            elseif ($browserName -like "Brave*") { Convert-ChromiumBookmarksToHtml -jsonPath $sourcePath -outputFile $destFile }
            elseif ($browserName -like "Opera*") { Convert-ChromiumBookmarksToHtml -jsonPath $sourcePath -outputFile $destFile }
            elseif ($browserName -like "Mozilla Firefox*") { Convert-FirefoxToHtml -sqlitePath $sourcePath -outputFile $destFile }
            elseif ($browserName -like "Internet Explorer*") { Convert-IEFavoritesToHtml -favPath $sourcePath -outputFile $destFile }
            else { Add-Content -Path $LogFile -Value "No conversion rule for $browserName"; Write-Host "No conversion rule for $browserName" }

            Write-Host "Exported $browserName bookmarks to $destFile"
            Add-Content -Path $LogFile -Value "Exported $browserName -> $destFile"
        } catch {
            Write-Host ("Failed to export {0}: {1}" -f $browserName, $_.Exception.Message) -ForegroundColor Red
            Add-Content -Path $LogFile -Value ("Failed to export {0}: {1}" -f $browserName, $_.Exception.Message)
        }
    }
}

Write-Host "`nAll done! Bookmarks exported as HTML in: $OutputFolder"
Add-Content -Path $LogFile -Value "Completed at $(Get-Date -Format u)"
Read-Host
}
$MenuVar = 999

While ($MenuVar -ne 0 ) {
    Clear-Host
    Write-Host "Version 1.0"
    Write-Host "----------------------------------"
    Write-Host "Pick your poison." -ForegroundColor Red
    Write-Host "----------------------------------"
    Write-Host "1. Update Windows PC" -ForegroundColor Blue
    Write-Host "2. Configure adapters" -ForegroundColor Blue
    Write-Host "3. Clear space" -ForegroundColor Blue
    Write-Host "4. Speed test" -ForegroundColor Blue
    Write-Host "5. Bookmark extraction" -ForegroundColor Blue
    Write-Host "To exit, press 0." -ForegroundColor Blue
    $MenuVar = Read-Host "Choose your fighter"
    if ($MenuVar -eq 1) {
        UpdateWindows
    }
     if ($MenuVar -eq 2) {
        NetAdapt
    }
    if ($MenuVar -eq 4) {
        SpeedTest
    }
    if ($MenuVar -eq 3) {
        ClearSpace
    }
if ($MenuVar -eq 5) {
        Bookmark
    }
}
